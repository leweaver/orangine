import json
import argparse
import io, os

def camel(words):
    if isinstance(words, str):
        words = words.split(' ')
    
    return ''.join(w[0].upper() + w[1:] for w in words)

def camel_first_lower(words):
    camelStr = camel(words)
    return camelStr[0].lower() + camelStr[1:]

def underscores(words):
    if isinstance(words, str):
        words = words.split(' ')
    return '_'.join(words)

def underscores_first_upper(words):
    underscoresStr = underscores(words)
    underscoresStr = underscoresStr[0].upper() + underscoresStr[1:]
    return underscoresStr

def generate(filepath_json):
    enums_json = json.load(open(filepath_json))

    dn = os.path.dirname(filepath_json)
    filepath_h = dn + "/" + enums_json["output_header"]
    filepath_cpp = dn + "/" + enums_json["output_cpp"]

    # Write header file
    output_header = """#pragma once
// GENERATED BY codegen-enum.py
// Do not modify manually!

#include <string>

namespace oe {
"""

    cpp_includes = '\n'.join(f"#include \"{i}\"" for i in enums_json.get('includes', []))
    output_cpp = f"""// GENERATED BY codegen-enum.py
// Do not modify manually!

{cpp_includes}

namespace oe {{
"""

    # Render the enum code
    enum_count = 0
    for enum_def in enums_json['enums']:

        enum_def_name = enum_def.get('name')
        if enum_def_name == '':
            continue

        enum_count += 1

        name_words = enum_def_name.split(' ')

        # is_flags = enum_def.get('is_flags', False)
        cpp_enum_name = underscores_first_upper(name_words)
        cpp_count_value_name = f"{underscores_first_upper(['num'] + name_words)}"
        cpp_tostr_fn_name = f"{camel_first_lower(name_words)}ToString"
        cpp_fromstr_fn_name = f"stringTo{camel(name_words)}"
        cpp_array_name = f"g_{camel_first_lower(name_words)}Names"

        # Create header file
        output_header += f"""
// {cpp_enum_name}
enum class {cpp_enum_name} {{
"""
        current_index = enum_def.get('first_index', 0)

        enum_val_names = []
        for enum_val in enum_def.get('values'):
            enum_val_name = underscores_first_upper(enum_val if isinstance(enum_val, str) else enum_val['name'])
            enum_val_num = current_index if isinstance(enum_val, str) else enum_val['value']

            enum_val_names.append(enum_val_name)

            print_number = f" = {enum_val_num}" if current_index == 0 or not isinstance(enum_val, str) else ""
            output_header += f"  {enum_val_name}{print_number},\n"
            current_index += 1

        
        output_header += f"\n  {cpp_count_value_name} = {current_index},\n"
        output_header += "};"

        output_header += f"\nconst std::string& {cpp_tostr_fn_name}({cpp_enum_name} enumValue);"
        output_header += f"\n{cpp_enum_name} {cpp_fromstr_fn_name}(const std::string& str);"
        output_header += "\n"

        # Create cpp file
        cpp_enum_val_names = ",\n".join(f"    \"{n}\"" for n in enum_val_names)
        output_cpp += f"""
///////////////////////////////////
// {cpp_enum_name}
//
std::string {cpp_array_name}[] = {{
{cpp_enum_val_names}
}};
static_assert(static_cast<size_t>({cpp_enum_name}::{cpp_count_value_name}) == array_size({cpp_array_name}));
const std::string& {cpp_tostr_fn_name}({cpp_enum_name} enumValue)
{{
    return {cpp_array_name}[static_cast<size_t>(enumValue)];
}}
{cpp_enum_name} {cpp_fromstr_fn_name}(const std::string & str)
{{
    return stringToEnum<{cpp_enum_name}>(str, {cpp_array_name});
}}
"""

    output_header += "\n} // namespace oe"
    output_cpp += "\n} // namespace oe"
    
    with open(filepath_h, "r") as header_file:        
        if (output_header == header_file.read()):
            print (f"enums up to date.")
            return

    with open(filepath_h, "w") as header_file:
        header_file.write(output_header)
        print (f"wrote {enum_count} enums to {filepath_h}")

    with open(filepath_cpp, "w") as cpp_file:
        cpp_file.write(output_cpp)
        print (f"wrote {enum_count} enums to {filepath_cpp}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--json", type=str, default="OeCore/codegen/Renderer_enums.json", help="The source enum json file")

    args = parser.parse_args()

    generate(args.json)