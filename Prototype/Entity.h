#pragma once

#include <DirectXMath.h>
#include <vector>
#include "Component.h"

namespace OE {

class EntityManager;
__declspec(align(16)) class Entity
{
	friend EntityManager;
	typedef std::vector<std::unique_ptr<Entity>> EntityVector;

	// Generated by a call to ApplyWorldTransform
	DirectX::XMMATRIX m_worldTransform; 

	DirectX::XMVECTOR m_localRotation;  
	DirectX::XMVECTOR m_localPosition;  // w is ignored
	DirectX::XMVECTOR m_localScale;		// w is ignored
	
	unsigned int m_id;
	const std::string m_name;
	bool m_active = true;

	EntityVector m_children;
	Entity* m_parent;
	EntityManager& m_entityManager;

	std::vector<std::unique_ptr<Component>> m_components;

	explicit Entity(EntityManager& entityManager, std::string name, unsigned int id)
		: m_id(id)
		, m_name(name)
		, m_parent(nullptr)
		, m_entityManager(entityManager)
	{
	}

protected:
	bool HasParent() const { return m_parent != nullptr; }
	void ApplyWorldTransform();

public:
	/* If true, Update method will be called by parent during recursion. */
	bool IsActive() const { return m_active; }
	void SetActive(bool bActive);

	void RemoveParent();
	void SetParent(Entity& newParent);
	void Update();

	unsigned int GetComponentCount() const { return m_components.size(); }

	Component& GetComponent(unsigned int index) const;

	template<typename TComponent>
	TComponent& AddComponent(const std::string name)
	{
		Component* component = new TComponent(name);
		m_components.push_back(std::unique_ptr<Component>(component));
		return *component;
	}

	void* operator new(size_t i)
	{
		return _mm_malloc(i, 16);
	}

	void operator delete(void* p)
	{
		_mm_free(p);
	}

};

}
