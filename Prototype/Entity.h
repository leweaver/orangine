#pragma once

#include <DirectXMath.h>
#include <vector>
#include "Component.h"
#include <map>
#include "Constants.h"

namespace OE {

	class Scene;
	class SceneGraphManager;
	__declspec(align(16)) class Entity
	{
		friend SceneGraphManager;

		typedef unsigned int ID_TYPE;
		typedef std::vector<std::shared_ptr<Entity>> EntityPtrVec;
		typedef std::map<ID_TYPE, std::shared_ptr<Entity>> EntityPtrMap;

		// Generated by a call to ComputeWorldTransform
		DirectX::XMMATRIX m_worldTransform;
		DirectX::XMVECTOR m_worldScale;		// w is ignored

		DirectX::XMVECTOR m_localRotation;
		DirectX::XMVECTOR m_localPosition;  // w is ignored
		DirectX::XMVECTOR m_localScale;		// w is ignored

		ID_TYPE m_id;
		const std::string m_name;
		bool m_active;

		EntityPtrVec m_children;
		Entity* m_parent;
		Scene& m_scene;

		Component* blah;

		std::vector<std::unique_ptr<Component>> m_components;

		explicit Entity(Scene& scene, std::string name, ID_TYPE id)
			: m_worldTransform(Math::MAT4_IDENTITY)
			, m_localRotation(Math::QUAT_IDENTITY)
			, m_localPosition(Math::VEC_ZERO)
			, m_localScale(Math::VEC_ONE)
			, m_id(id)
			, m_name(name)
			, m_active(true)
			, m_parent(nullptr)
			, m_scene(scene)
		{
		}

		/**
		 * Called when the scene has completed loading, before the game loop starts.
		 * If entities are created after the game loop starts, this is called immediately.
		 */
		void Initialize();

	protected:
		bool HasParent() const { return m_parent != nullptr; }

	public:

		// Don't allow direct copy of Entity objects (we have a unique_ptr list of components).
		Entity(const Entity& that) = delete;

		/* If true, Update method will be called by parent during recursion. */
		bool IsActive() const { return m_active; }
		void SetActive(bool bActive);

		void RemoveParent();
		void SetParent(Entity& newParent);

		/**
		* Applies transforms recursively down (from root -> leaves),
		* then updates components from bottom up (from leaves -> root)
		*/
		void Update();

		/**
		 * Computes the world transformation matrix for just this entity. (Non-recursive)
		 */
		void ComputeWorldTransform();

		const ID_TYPE& GetId() const { return m_id; }
		size_t GetComponentCount() const { return m_components.size(); }

		Component& GetComponent(size_t index) const;

		template<typename TComponent>
		std::vector<std::reference_wrapper<TComponent>> GetComponentsOfType() const;

		/* Math Functions */
		void LookAt(const Entity& other);

		/**
		 * returns a nullptr if no component of given type was found.
		 */
		template<typename TComponent>
		TComponent* GetFirstComponentOfType() const;

		template<typename TComponent>
		TComponent& AddComponent();

		// Object must be 16 bit aligned, since it contains DirectX structs.
		void* operator new(size_t i)
		{
			return _mm_malloc(i, 16);
		}

		void operator delete(void* p)
		{
			_mm_free(p);
		}

		const DirectX::XMMATRIX& GetWorldTransform() const
		{
			return m_worldTransform;
		}

		const DirectX::XMVECTOR& LocalRotation() const
		{
			return m_localRotation;
		}

		void SetLocalRotation(const DirectX::FXMVECTOR& xmvector)
		{
			m_localRotation = xmvector;
		}

		const DirectX::XMVECTOR& LocalPosition() const
		{
			return m_localPosition;
		}

		void SetLocalPosition(const DirectX::FXMVECTOR& xmvector)
		{
			m_localPosition = xmvector;
		}

		const DirectX::XMVECTOR& LocalScale() const
		{
			return m_localScale;
		}

		void SetLocalScale(const DirectX::FXMVECTOR& xmvector)
		{
			m_localScale = xmvector;
		}

		Scene& GetScene() const
		{
			return m_scene;
		}

		const DirectX::XMVECTOR& Scale() const;
		DirectX::XMVECTOR Position() const;
		DirectX::XMVECTOR Rotation() const;

	private:
		/*
		* Redirect events to the Scene.
		*/
		void OnComponentAdded(Component& component);
	};

	template <typename TComponent>
	std::vector<std::reference_wrapper<TComponent>> Entity::GetComponentsOfType() const
	{
		std::vector<std::reference_wrapper<TComponent>> comps;
		for (auto iter = m_components.begin(); iter != m_components.end(); ++iter)
		{
			TComponent* comp = dynamic_cast<TComponent*>((*iter).get());
			if (comp != nullptr)
				comps.push_back(std::reference_wrapper<TComponent>(*comp));
		}
		return comps;
	}

	template <typename TComponent>
	TComponent* Entity::GetFirstComponentOfType() const
	{
		for (auto iter = m_components.begin(); iter != m_components.end(); ++iter)
		{
			const auto comp = dynamic_cast<TComponent*>((*iter).get());
			if (comp != nullptr)
				return comp;
		}
		return nullptr;
	}

	template <typename TComponent>
	TComponent& Entity::AddComponent()
	{
		TComponent* component = new TComponent();
		m_components.push_back(std::unique_ptr<Component>(component));

		this->OnComponentAdded(*component);

		return *component;
	}
}

