#pragma once

#include <DirectXMath.h>
#include <vector>
#include "Component.h"
#include <map>

namespace OE {

class EntityManager;
__declspec(align(16)) class Entity
{
	friend EntityManager;

	typedef unsigned int ID_TYPE;
	typedef std::vector<std::shared_ptr<Entity>> EntityPtrVec;
	typedef std::map<ID_TYPE, std::shared_ptr<Entity>> EntityPtrMap;

	// Generated by a call to ApplyWorldTransform
	DirectX::XMMATRIX m_worldTransform; 

	DirectX::XMVECTOR m_localRotation;  
	DirectX::XMVECTOR m_localPosition;  // w is ignored
	DirectX::XMVECTOR m_localScale;		// w is ignored
	
	ID_TYPE m_id;
	const std::string m_name;
	bool m_active = true;

	EntityPtrVec m_children;
	Entity* m_parent;
	EntityManager& m_entityManager;

	std::vector<std::unique_ptr<Component>> m_components;

	explicit Entity(EntityManager& entityManager, std::string name, ID_TYPE id)
		: m_id(id)
		, m_name(name)
		, m_parent(nullptr)
		, m_entityManager(entityManager)
	{
	}

protected:
	bool HasParent() const { return m_parent != nullptr; }
	void ApplyWorldTransform();

public:

	// Don't allow direct copy of Entity objects (we have a unique_ptr list of components).
	Entity(const Entity& that) = delete;

	/* If true, Update method will be called by parent during recursion. */
	bool IsActive() const { return m_active; }
	void SetActive(bool bActive);

	void RemoveParent();
	void SetParent(Entity& newParent);
	void Update();

	const ID_TYPE& GetId() const { return m_id; }
	unsigned int GetComponentCount() const { return m_components.size(); }
	
	Component& GetComponent(unsigned int index) const;
	
	template<typename TComponent>
	std::vector<std::reference_wrapper<TComponent>> GetComponentsOfType() const;

	/**
	 * returns a nullptr if no component of given type was found.
	 */
	template<typename TComponent>
	TComponent* GetFirstComponentOfType() const;

	template<typename TComponent>
	TComponent& AddComponent();

	// Object must be 16 bit aligned, since it contains DirectX structs.
	void* operator new(size_t i)
	{
		return _mm_malloc(i, 16);
	}

	void operator delete(void* p)
	{
		_mm_free(p);
	}
};

	template <typename TComponent>
	std::vector<std::reference_wrapper<TComponent>> Entity::GetComponentsOfType() const
	{
		std::vector<std::reference_wrapper<TComponent>> comps;
		for (auto iter = m_components.begin(); iter != m_components.end(); ++iter)
		{
			TComponent* comp = dynamic_cast<TComponent*>((*iter).get());
			if (comp != nullptr)
				comps.push_back(std::reference_wrapper<TComponent>(*comp));
		}
		return comps;
	}

	template <typename TComponent>
	TComponent* Entity::GetFirstComponentOfType() const
	{
		for (auto iter = m_components.begin(); iter != m_components.end(); ++iter)
		{
			const auto comp = dynamic_cast<TComponent*>((*iter).get());
			if (comp != nullptr)
				return comp;
		}
		return nullptr;
	}

	template <typename TComponent>
	TComponent& Entity::AddComponent()
	{
		TComponent* component = new TComponent();
		m_components.push_back(std::unique_ptr<Component>(component));
		return *component;
	}
}

